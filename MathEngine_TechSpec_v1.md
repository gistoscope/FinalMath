# Math Engine Application — Technical Specification v1.0
*(Engine • Viewer • MapMaster • StepMaster • Diagnostics)*

## 0. Purpose and scope

This document describes the full technical design of the Math Engine application:

- End‑to‑end flow from **Viewer (frontend)** to **Engine (backend)** and back.
- Responsibilities and contracts for:
  - **Engine / NGIN** (LaTeX → AST → primitives),
  - **MapMaster** (step map generator),
  - **StepMaster** (orchestrator, strategies, invariants usage),
  - **Display / Viewer side adapters**.
- JSON / TypeScript contracts between components.
- Debug / diagnostics tools (AST / Map / Step inspectors) for engineers.

Language of business logic and code examples: **TypeScript / English**.  
Explanations and comments may be in English or Russian depending on usage context.

This spec is oriented towards software engineers who will implement and maintain the system.

---

## 1. High‑level architecture

### 1.1. Conceptual flow

1. Student enters a **LaTeX expression** in the Viewer.
2. Viewer sends a request to the backend **Engine**, asking to:
   - build or update the AST,
   - apply a step,
   - or introspect MapMaster / StepMaster.
3. **Engine (NGIN)** parses LaTeX into an **AST** with stable node IDs and paths.
4. **MapMaster** receives the AST and **selection** (click on operator/operand) and generates a **step map**:
   - identifies semantic windows,
   - resolves applicable invariants,
   - builds a list of **step candidates** (atomic student‑level steps).
5. **StepMaster** receives the step map, session state and a chosen mode (student/manual, autopilot, teacher) and:
   - selects a concrete step or sequence of steps,
   - instructs Engine which primitives to apply.
6. **Engine / PrimitiveRunner** applies primitives to the AST and produces:
   - updated AST,
   - updated LaTeX,
   - optional metadata for Viewer.
7. Viewer receives the updated expression and metadata, updates the UI and history.

### 1.2. Major modules

- **Frontend / Viewer layer**
  - `viewer` — renders LaTeX and interactive formula.
  - `display-adapter` — maps backend JSON to Viewer internal model.
  - `engine-adapter` — wraps HTTP calls to backend.

- **Backend / Core**
  - `engine-lite` (NGIN) — LaTeX parser, AST model, PrimitiveRunner.
  - `primitives.registry` — catalog of primitive operations.
  - `invariants.registry` — catalog of invariants (compound rules over primitives).
  - `mapmaster` — step map generator.
  - `stepmaster` — orchestration and strategies.
  - `backend-api-b1.http-server` — HTTP layer (REST endpoints, JSON contracts).

- **Diagnostics & Dev Tools**
  - AST debug view (`/api/ast-debug`).
  - Map debug view (`/api/mapmaster-debug`).
  - Step pipeline debug (`/api/step-debug`).

---

## 2. Data model — AST, IDs, and paths

### 2.1. AST ownership

- **Engine / NGIN** is the sole owner and source of truth for:
  - AST representation,
  - node identifiers,
  - path semantics.

- MapMaster and StepMaster **never mutate** the AST directly and never change node IDs:
  - they only read AST and refer to nodes by IDs and/or paths.
  - they request AST modifications by calling Engine primitives.

### 2.2. AST types

Core TypeScript types (simplified):

```ts
/** Unique identifier for AST node, generated by Engine. */
export type AstNodeId = string;

/** Path from AST root to node, stable and deterministic. */
export type AstPath = string[];

export type AstNodeKind =
  | "IntegerLiteral"
  | "RationalLiteral"      // fraction: numerator/denominator
  | "Identifier"
  | "Add"
  | "Subtract"
  | "Multiply"
  | "Divide"
  | "Power"
  | "Parenthesized"
  | "UnaryMinus"
  | "MixedNumber"          // integer + proper fraction
  | "Other";               // fallback

export interface AstNodeBase {
  id: AstNodeId;
  path: AstPath;
  kind: AstNodeKind;
  latex: string;           // LaTeX for this subexpression
}

export interface AstBinaryNode extends AstNodeBase {
  kind: "Add" | "Subtract" | "Multiply" | "Divide" | "Power";
  left: AstNode;
  right: AstNode;
}

export interface AstRationalNode extends AstNodeBase {
  kind: "RationalLiteral";
  numerator: AstNode;
  denominator: AstNode;
}

export interface AstIntegerLiteralNode extends AstNodeBase {
  kind: "IntegerLiteral";
  value: number;
}

export type AstNode =
  | AstBinaryNode
  | AstRationalNode
  | AstIntegerLiteralNode
  | AstNodeBase;   // parenthesized, identifiers etc.

export interface AstRoot {
  rootId: AstNodeId;
  nodes: Record<AstNodeId, AstNode>;
}
```

### 2.3. ID and path requirements

- **ID uniqueness**: each node `AstNodeId` is unique within a single AST.
- **Path stability**: `AstPath` is deterministic for a given AST structure; re‑parsing same LaTeX must generate same paths.
- **No mutation**: Engine may replace entire AST on step application, but MapMaster/StepMaster must treat AST as immutable input.

---

## 3. Primitives and invariants

### 3.1. Primitive

Primitive is a low‑level, mathematically sound transformation over AST. Example:

- `PRIM_ADD_FRACTIONS_SAME_DEN_STAGE1`
- `PRIM_ADD_INTEGERS`
- `PRIM_MULTIPLY_BY_ONE`
- `PRIM_ADD_ZERO`

```ts
export type PrimitiveId = string;

export interface PrimitiveContext {
  ast: AstRoot;
  targetPath: AstPath;
}

export interface PrimitiveResult {
  ast: AstRoot;
  description: string; // short technical message, for logs/tests
}

export type PrimitiveFn = (ctx: PrimitiveContext) => PrimitiveResult;

export interface PrimitiveDefinition {
  id: PrimitiveId;
  domain: "Fractions" | "Integers" | "Mixed" | "Generic";
  run: PrimitiveFn;
}
```

### 3.2. Invariant

Invariant describes a *mathematical pattern* or a *student‑level step template* that may internally use one or more primitives. Examples:

- `INV_FRAC_ADD_SAME_DEN_STAGE1`
- `INV_INT_ADD_STAGE1`
- `INV_MIXED_ADD_INT_FRAC_SAME_DEN_STAGE1`
- `INV_MULTIPLY_BY_ONE_IDENTITY`

```ts
export type InvariantId = string;

export interface InvariantPattern {
  domain: "Fractions" | "Integers" | "Mixed" | "Generic";
  // Additional structural constraints, like
  // same denominator, positive integers, etc.
}

export interface InvariantApplyPlan {
  primitiveIds: PrimitiveId[];  // sequence of primitives
}

export interface InvariantDefinition {
  id: InvariantId;
  pattern: InvariantPattern;
  plan: InvariantApplyPlan;
}
```

### 3.3. Registries

Primitives registry:

```ts
export interface PrimitiveRegistry {
  get(id: PrimitiveId): PrimitiveDefinition | undefined;
  list(): PrimitiveDefinition[];
}
```

Invariants registry:

```ts
export interface InvariantRegistry {
  get(id: InvariantId): InvariantDefinition | undefined;
  list(): InvariantDefinition[];
  findMatching(pattern: InvariantPattern): InvariantDefinition[];
}
```

**Ownership**:
- Engine/NGIN uses `PrimitiveRegistry` to actually transform AST.
- MapMaster uses `InvariantRegistry` to decide what can be applied on a given AST window.

---

## 4. MapMaster — step map generator

### 4.1. Responsibility

MapMaster is a pure analytical module that:

- receives AST and selection (click info),
- constructs semantic windows around the anchor,
- queries invariants and builds **step candidates**,
- returns **what is mathematically and pedagogically possible to do now**, without choosing which step to take.

MapMaster does **not**:

- change AST,
- apply primitives,
- select one “best” step (StepMaster’s responsibility).

### 4.2. Input: selection and context

```ts
export type SelectionKind = "Operator" | "Operand";

export interface ViewerSelection {
  kind: SelectionKind;
  astPath?: AstPath;       // preferred
  operatorIndex?: number;  // optional fallback
}

export interface MapMasterInput {
  ast: AstRoot;
  selection: ViewerSelection;
  mode: "Stage1" | "Advanced" | "Debug";
}
```

### 4.3. Step candidate

```ts
export type DomainId = "FractionsSameDen" | "Integers" | "MixedSameDen" | "Generic";

export interface MapMasterStepCandidateId {
  domain: DomainId;
  invariantId: InvariantId;
  anchorNodeId: AstNodeId;
}

export interface MapMasterStepCandidate {
  id: MapMasterStepCandidateId;
  targetPath: AstPath;            // where to apply primitives
  primitiveIds: PrimitiveId[];    // ordered list
  displayLabel: string;           // human label ("Add numerators, keep denominator")
  difficulty: number;             // 1..n
  tags: string[];                 // e.g. ["fractions", "stage1"]
}
```

### 4.4. MapMaster pipeline

MapMaster is implemented as a pipeline of sub‑components:

1. **SelectionNormalizer**
   - Receives `MapMasterInput.selection` and `AstRoot`.
   - Produces a normalized anchor:
     ```ts
     export interface NormalizedSelection {
       status: "ok" | "no-anchor" | "invalid";
       anchorNodeId?: AstNodeId;
       anchorKind?: SelectionKind;
     }
     ```

2. **WindowBuilder / AST helpers**
   - Based on `anchorNodeId`, extracts semantic window:
     ```ts
     export interface SemanticWindow {
       domain: DomainId;
       operation: "+" | "-" | "*" | "/" | "other";
       anchorNodeId: AstNodeId;
       nodeIds: AstNodeId[];  // nodes in the window
     }
     ```

3. **RuleProvider**
   - Maps semantic window → candidate invariant IDs:
     ```ts
     export interface RuleProvider {
       getInvariantsForWindow(window: SemanticWindow): InvariantId[];
     }
     ```

4. **InvariantRegistryAdapter**
   - Bridges RuleProvider and core `InvariantRegistry`:
     - resolves invariant definitions,
     - ensures compatibility of domain and pattern,
     - yields `InvariantDefinition[]`.

5. **CandidateBuilder**
   - For each `InvariantDefinition`, constructs one or more `MapMasterStepCandidate` objects.

### 4.5. MapMaster main API

```ts
export interface MapMasterResult {
  candidates: MapMasterStepCandidate[];
  meta: {
    source: "mapmaster-core";
    status: "ok" | "no-candidates" | "selection-error";
  };
}

export function mapMasterGenerate(input: MapMasterInput): MapMasterResult;
```

### 4.6. MapMaster debug API

For diagnostics and unit testing, a debug function returns a full pipeline trace:

```ts
export interface MapMasterDebugPipeline {
  selection: {
    status: "ok" | "no-anchor" | "invalid";
    anchorNodeId?: AstNodeId;
    anchorKind?: SelectionKind;
  };
  window: {
    status: "ok" | "no-window";
    domain?: DomainId;
    operation?: string;
    nodeIds?: AstNodeId[];
  };
  invariants: {
    status: "found" | "none";
    ids?: InvariantId[];
  };
  rules: {
    status: "candidates-produced" | "no-rules-fired";
    candidateCount: number;
    checkedInvariantIds?: InvariantId[];
    reasonIfNone?: string;
  };
}

export interface MapMasterDebugResult {
  input: MapMasterInput;
  astSnapshot: AstRoot;
  pipeline: MapMasterDebugPipeline;
  candidates: MapMasterStepCandidate[];
}

export function mapMasterDebug(input: MapMasterInput): MapMasterDebugResult;
```

HTTP debug endpoint (internal only):

- `POST /api/mapmaster-debug`
  - Request: same as applyStep (expression + selection).
  - Response: `MapMasterDebugResult` as JSON.

---

## 5. StepMaster — orchestration and strategies

### 5.1. Responsibility

StepMaster consumes:
- map of candidates from MapMaster,
- current session state,
- chosen **mode** and **strategy**,

and produces:
- a **selected step** or a **sequence of steps**,
- commands for Engine (which primitives to run and where),
- enriched metadata for Viewer (explanations, hints).

StepMaster does **not**:
- change AST directly,
- prove mathematical correctness (relies on primitives/invariants).

### 5.2. Modes

Example modes:

- `StudentStrict` — one minimal atomic step at a time; no skipping.
- `StudentRelaxed` — can combine several primitives into one visible step if allowed by invariant.
- `Autopilot` — StepMaster selects and runs best next step automatically.
- `TeacherStrategy` — allow “hard” strategies: adding 0, multiplying by 1, turning 1 into `3/3`, etc.

### 5.3. Core types

```ts
export type StepMasterMode =
  | "StudentStrict"
  | "StudentRelaxed"
  | "Autopilot"
  | "TeacherStrategy";

export interface StepMasterSessionState {
  history: AppliedStepRecord[];
  undone: AppliedStepRecord[];
  mode: StepMasterMode;
}

export interface AppliedStepRecord {
  id: string;
  candidateId: MapMasterStepCandidateId;
  primitiveIds: PrimitiveId[];
  beforeAst: AstRoot;
  afterAst: AstRoot;
  metadata: Record<string, unknown>;
}

export interface StepMasterDecision {
  selectedCandidate: MapMasterStepCandidate | null;
  primitiveIdsToRun: PrimitiveId[];
  targetPath: AstPath | null;
  explanation: string;
}
```

### 5.4. API

```ts
export interface StepMasterInput {
  ast: AstRoot;
  map: MapMasterResult;
  session: StepMasterSessionState;
}

export interface StepMasterOutput {
  decision: StepMasterDecision;
  updatedSession: StepMasterSessionState;
}

export function stepMasterDecide(input: StepMasterInput): StepMasterOutput;
```

### 5.5. History and undo/redo

StepMaster is also responsible for:

- pushing `AppliedStepRecord` into history after each Engine application,
- handling undo/redo operations,
- generating human‑readable descriptions for step history.

---

## 6. Engine / NGIN — parsing and primitives execution

### 6.1. Responsibility

Engine / NGIN:

- parses LaTeX into AST with IDs and paths,
- maintains PrimitiveRunner,
- executes primitives to transform AST,
- exposes core backend HTTP API (`/api/engine` etc.).

### 6.2. Parse API

```ts
export interface ParseLatexRequest {
  latex: string;
}

export interface ParseLatexResponse {
  type: "ok" | "error";
  ast?: AstRoot;
  message?: string;
}
```

### 6.3. Apply primitives API (internal)

```ts
export interface EngineApplyPrimitivesRequest {
  ast: AstRoot;
  targetPath: AstPath;
  primitiveIds: PrimitiveId[];
}

export interface EngineApplyPrimitivesResult {
  type: "ok" | "error";
  ast?: AstRoot;
  latex?: string;
  message?: string;
}
```

### 6.4. PrimitiveRunner contract

```ts
export interface PrimitiveRunner {
  runMany(
    ctx: PrimitiveContext,
    primitiveIds: PrimitiveId[]
  ): PrimitiveResult;
}
```

---

## 7. Backend HTTP API (backend-api-b1.http-server)

### 7.1. Main step endpoint

`POST /api/engine-step`

Request:

```ts
export type EngineStepRequestType = "applyStep" | "undo" | "redo";

export interface EngineStepRequest {
  type: EngineStepRequestType;
  expressionLatex: string;
  selection?: ViewerSelection;        // for applyStep
  sessionId?: string;                 // for history
}
```

Response (canonical structure):

```ts
export interface EngineStepResponse {
  type: "ok" | "error";
  requestType: EngineStepRequestType;
  message?: string;

  result?: {
    latex: string;
    ast: AstRoot;
    meta: {
      source: "backend-entry-step";
      status: "ok" | "no-candidates" | "selection-error" | "step-applied";
      candidatesCount?: number;
      appliedStepId?: string;
    };
    diagnostics?: {
      // optional debug info for teachers / developers
    };
  };
}
```

### 7.2. MapMaster debug endpoint

`POST /api/mapmaster-debug`

- Request: same as `applyStep` but with debug flag.
- Response: `MapMasterDebugResult`.

### 7.3. AST debug endpoint

`POST /api/ast-debug`

Request:

```ts
export interface AstDebugRequest {
  latex: string;
}
```

Response:

```ts
export interface AstDebugResponse {
  type: "ok" | "error";
  ast?: AstRoot;
  message?: string;
}
```

---

## 8. Frontend / Viewer & adapters

### 8.1. Viewer responsibilities

- Render LaTeX and math UI.
- Capture user interactions:
  - clicks on operators/operands,
  - navigation in history,
  - mode selection (student/teacher).

- Forward user actions to `engine-adapter` as **high‑level commands**.

### 8.2. Engine adapter (frontend)

Example interface (TypeScript in frontend):

```ts
export interface EngineAdapter {
  applyStep(latex: string, selection: ViewerSelection): Promise<EngineStepResponse>;
  undo(sessionId: string): Promise<EngineStepResponse>;
  redo(sessionId: string): Promise<EngineStepResponse>;
  debugMap(latex: string, selection: ViewerSelection): Promise<MapMasterDebugResult>;
}
```

### 8.3. Display adapter

- Maps backend `EngineStepResponse` to Viewer model:

```ts
export interface ViewerExpressionState {
  latex: string;
  ast?: AstRoot;   // for dev tools
  meta?: EngineStepResponse["result"]["meta"];
}

export interface DisplayAdapter {
  applyEngineResponse(
    prevState: ViewerExpressionState,
    response: EngineStepResponse
  ): ViewerExpressionState;
}
```

---

## 9. Diagnostics and debugging tools

### 9.1. JSON snapshots for engineers

The system must provide JSON‑level access to:

1. **AST snapshot** (LaTeX → AST with IDs/paths).
2. **Map snapshot** (AST + semantic window + candidates).
3. **Step pipeline** (selection, MapMaster pipeline state, StepMaster decision, primitives executed).

### 9.2. Dev‑only viewers

For internal use (not for students), we define:

- A lightweight **AST Viewer**:
  - displays nodes in tree form,
  - shows `id`, `kind`, `latex`, and children.

- A **Map Viewer**:
  - shows AST,
  - highlights semantic window nodes,
  - lists all `MapMasterStepCandidate` objects attached to nodes.

- A **Step pipeline viewer**:
  - shows which candidate StepMaster chose,
  - shows primitive sequence and their effect on AST.

These viewers consume the same JSON structures defined in this spec and can be implemented as separate dev‑tools pages.

---

## 10. Folder and file layout (reference)

A reference layout for the monorepo:

```text
packages/
  viewer/
    src/
      viewer-app.tsx
      engine-adapter.ts
      display-adapter.ts

  engine-lite/
    src/
      ast/
        ast.types.ts
        parser.latex.ts
      primitives/
        primitives.registry.ts
        primitive.runner.ts

  invariants/
    src/
      invariants.registry.ts
      invariants.fractions.ts
      invariants.integers.ts

  mapmaster/
    src/
      mapmaster.core.ts
      mapmaster.selection-normalizer.ts
      mapmaster.ast-helpers.ts
      mapmaster.rule-provider.ts
      mapmaster.invariants.registry-adapter.ts
      mapmaster.rules.fractions.stage1.ts
      mapmaster.rules.integers.stage1.ts
      mapmaster.rules.mixed.stage1.ts

  stepmaster/
    src/
      stepmaster.core.ts
      stepmaster.session-store.ts
      stepmaster.history-store.ts
      stepmaster.modes.ts

  backend-api-b1.http-server/
    src/
      http.server.ts
      http.routes.engine-step.ts
      http.routes.mapmaster-debug.ts
      http.routes.ast-debug.ts
```

(Actual paths in the current repo may differ, but contracts and responsibilities must match.)

---

## 11. Non‑functional requirements and invariants

1. **Determinism**  
   - For the same LaTeX and same selection, the pipeline must produce the same AST, same map, same step decision (unless mode/strategy differ).

2. **Atomicity**  
   - Each visible step (student‑level) must be reversible and explainable in terms of one invariant and a finite sequence of primitives.

3. **Reversibility / Undo**  
   - It must always be possible to revert a step via history (StepMaster).  
   - No hidden mutations that bypass history.

4. **Traceability**  
   - Every step is linked to:
     - AST before/after,
     - `candidateId` and `invariantId`,
     - list of `primitiveIds` applied.

5. **Isolation of responsibilities**  
   - Engine defines AST and primitives (math correctness).  
   - MapMaster defines what can be done now (step map).  
   - StepMaster defines how we will walk this map (strategies, modes).  
   - Viewer defines how this is presented to the student.

---

## 12. Summary

This specification defines:

- Data structures (AST, primitives, invariants, candidates, history records),
- Clear boundaries between Engine, MapMaster, StepMaster and Viewer,
- JSON/TypeScript contracts for runtime and debug flows,
- Diagnostic tooling to inspect LaTeX → AST → Map → Step chain.

Any future changes to implementation (internal algorithms, data structures) must preserve these contracts or update this specification accordingly, to keep the system maintainable and debuggable for engineers.
