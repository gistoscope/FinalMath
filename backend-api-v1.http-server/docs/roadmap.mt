# Motor Backend — Roadmap for TzV1.1 Implementation

Этот документ описывает подробную дорожную карту доведения backend до состояния, строго соответствующего техническому заданию **TzV1.1 – Minimal Backend Architecture for Motor (Orchestrator-based)**.

Структура:
- Секция A — общие принципы.
- Шаги 1–3 — расписаны очень детально.
- Шаги 4+ — даны более схематично, но в логическом порядке.

---

## A. Общие принципы

1. **Ориентир — TzV1.1**  
   Любое изменение оцениваем по вопросу: «Становится ли код ближе к TzV1.1 или дальше?».

2. **Модульность и “малые шаги”**  
   Мы не переписываем всё сразу. Для каждого блока:
   - выделяем минимальный инкремент (создать файл / выровнять типы / обрезать лишний API),
   - добиваемся зелёных тестов,
   - только потом идём к следующему блоку.

3. **Приоритет библиотек над orchestration/HTTP**  
   Сначала доводим до ума все **библиотечные модули** (Invariants, MapMaster, StepMaster, History, Policies, Engine Bridge),  
   и только затем собираем их в **Step Orchestrator** и HTTP-слой.

4. **Максимальная совместимость с существующим кодом**  
   - Используем уже написанные файлы Claude’ом там, где это не конфликтует с TzV1.1.
   - Старые файлы не удаляем, пока не убедимся, что новая реализация полностью их заменяет.

5. **Каждый шаг заканчивается артефактами**  
   Для каждого шага есть:
   - изменённые файлы,
   - мини-набор тестов,
   - короткое текстовое резюме «что изменилось и почему».

---

## Шаг 1. Стабилизация Invariants Model & Registry

### 1.1. Цель

Привести модуль **Invariants Model & Registry** к состоянию, когда он:

- строго соответствует разделу 4 TzV1.1;
- не содержит лишних экспериментальных вариантов;
- имеет понятный, стабильный и протестированный API;
- готов к использованию курс-лоудером и всеми остальными модулями.

### 1.2. Входные данные

- `src/invariants/invariants.model.ts`  
- `src/invariants/invariants.registry.ts`  
- `src/invariants/invariants.model.test.ts`  
- `src/invariants/invariants.registry.test.ts`  
- Устаревший файл: `src/invariants/invariants.model.new.ts` (экспериментальный вариант).

### 1.3. Подшаги

1. **Ревизия типов и API**  
   - Сверить фактические типы в `invariants.model.ts` и `invariants.registry.ts` с TzV1.1 (раздел 4):
     - `PrimitiveDefinition`
     - `InvariantRuleDefinition`
     - `InvariantSetDefinition`
     - `InvariantModelDefinition`
     - `InvariantModelIssue`
     - `InvariantModelValidationResult`
     - класс `InMemoryInvariantRegistry` и его методы.
   - Убедиться, что сигнатуры полностью совпадают:
     - имена типов,
     - структура полей,
     - типы возвращаемых значений.

2. **Проверка и корректировка валидации**  
   - Проанализировать реализацию `validateInvariantModel`:
     - есть ли проверки на дубликаты id;
     - проверяются ли типы полей (строки, массивы и т.д.);
     - проверяются ли ссылки (чтобы правило не ссылалось на несуществующий primitive).
   - При необходимости доработать валидацию, чтобы она точно реализовывала контракт TzV1.1.

3. **Реализация deep defensive copies**  
   - Проверить, как `InMemoryInvariantRegistry` хранит модель и что именно возвращает наружу:
     - массивы,
     - объекты,
     - вложенные структуры.
   - Внести изменения, чтобы все публичные методы возвращали **новые объекты** (deep copy):
     - модификация результатов не должна менять внутреннее состояние registry.

4. **Синхронизация тестов**  
   - Привести `invariants.model.test.ts` и `invariants.registry.test.ts` в соответствие с обновлённым контрактом:
     - добавить тесты на отрицательные сценарии (дубликаты id, неправильные типы);
     - добавить тесты на defensive copy (изменяем возвращаемую структуру и убеждаемся, что registry не меняется).

5. **Удаление устаревших вариантов**  
   - Найти все использования `invariants.model.new.ts` (если они есть).
   - Перевести эти места на текущий `invariants.model.ts` / registry.
   - После этого удалить `invariants.model.new.ts` из кода (или явно пометить как deprecated и исключить из сборки).

6. **Мини-отчёт по шагу 1**  
   Кратко описать:
   - какие проверки добавлены в валидацию;
   - как теперь реализован defensive copy;
   - какие старые файлы/типы убраны или изменены.

### 1.4. Результат шага 1

- Модуль Invariants:
  - полностью соответствует TzV1.1,
  - имеет чистый, документированный API,
  - не содержит экспериментальных дублей.
- Тесты успешны и проверяют ключевые инварианты.

### 1.5. Критерии “готово” для шага 1

- Нет упоминаний `invariants.model.new.ts` в рабочем коде.
- Все тесты invariants проходят.
- Любой разработчик может открыть TzV1.1 §4 и узнать всё необходимое о модуле из кода + тестов без дополнительных вопросов.

---

## Шаг 2. Реализация Invariant Course Loader и интеграция в старт сервера

### 2.1. Цель

Сделать так, чтобы backend **брал course (invariants + primitives) из JSON-файла** при старте:

- валидировал курс;
- строил `InMemoryInvariantRegistry`;
- падал на старте, если курс некорректен;
- предоставлял готовый registry остальным модулям.

### 2.2. Входные данные

- Стабилизированный модуль invariants после шага 1.
- Техническое задание TzV1.1 §5 (Invariant Course Loader).
- Текущий стартовый код HTTP-сервера:
  - например, `src/server/bootstrap.ts` / `src/index.ts` / аналогичный файл.
- (Опционально) уже существующие JSON- или TS-описания курсов.

### 2.3. Подшаги

1. **Выбор расположения и имени файла**  
   - Создать файл `src/invariants/invariants.course.loader.ts` (имя точно можно уточнить, но суть — loader).
   - Описать в нём интерфейс:

     ```ts
     export interface CourseLoaderConfig {
       path: string;
     }

     export function loadInvariantRegistryFromFile(
       config: CourseLoaderConfig
     ): InMemoryInvariantRegistry;
     ```

2. **Реализация loader’а**  
   - Внутри `loadInvariantRegistryFromFile`:
     - прочитать файл по `config.path` (с учётом возможного относительного пути от корня backend);
     - распарсить JSON в `unknown`;
     - вызвать `validateInvariantModel(parsed)`;
     - если `ok === false`:
       - вывести в лог список `issues` (с указанием уровней и id);
       - выбросить исключение (чтобы сервер не запустился);
     - если `ok === true`:
       - взять `result.model` и передать в `new InMemoryInvariantRegistry({ model: result.model })`;
       - вернуть полученный registry.

3. **Создание минимального course JSON**  
   - В каталоге `config/courses` создать файл:
     - `default.course.invariants.json`
   - Заполнить его минимальным, но валидным содержимым:
     - несколько простых primitives;
     - один invariant set с базовыми правилами для примера `3 + 2/5` (можно взять из текущего course’а Claude).

4. **Интеграция в старт сервера**  
   - Открыть файл, где стартует HTTP-сервер (bootstrap).
   - Заменить (или добавить):
     - вместо прямого использования hard-coded invariants — вызов `loadInvariantRegistryFromFile`;
     - путь `COURSE_FILE_PATH` взять из конфигурации (env или config-файл).

   - Пример (логика, не финальный код):

     ```ts
     const coursePath = process.env.COURSE_FILE_PATH ?? "config/courses/default.course.invariants.json";
     const invariantRegistry = loadInvariantRegistryFromFile({ path: coursePath });
     ```

   - Передать `invariantRegistry` внутрь контекста backend (позже он попадёт в OrchestratorContext).

5. **Обработка ошибок запуска**  
   - Убедиться, что при ошибке чтения/парсинга/валидации курс-файла:
     - сервер не продолжает запуск;
     - в лог попадает понятное сообщение (с указанием пути к файлу и списка проблем).

6. **Тестирование loader’а**  
   - Написать unit-тесты для `invariants.course.loader.ts`:
     - успешная загрузка валидного course-файла;
     - ошибка при отсутствии файла;
     - ошибка при некорректном JSON;
     - ошибка при некорректной структуре/ссылках внутри course-модели.

7. **Мини-отчёт по шагу 2**  
   - Список новых/изменённых файлов;
   - Описание конфигурации (`COURSE_FILE_PATH`);
   - Краткое описание поведения при ошибках.

### 2.4. Результат шага 2

- Backend стартует **только** при корректном course-файле.
- Invariants Registry создаётся централизованно через loader.
- У нас есть один “эталонный” course JSON, который можно развивать дальше.

### 2.5. Критерии “готово” для шага 2

- При удалении/порче `default.course.invariants.json` сервер не стартует и пишет в лог понятное сообщение.
- При корректном файле сервер стартует и registry доступен другим модулям.

---

## Шаг 3. MapMaster Core: выделение и выравнивание

### 3.1. Цель

Сделать чистый модуль **MapMaster Core**, который:

- реализует контракт TzV1.1 §6 (`MapMasterInput`, `MapMasterCandidate`, `MapMasterResult`, `mapMasterGenerate`);
- не зависит от HTTP, Orchestrator, UI;
- использует только Invariants Registry и локальные типы;
- умеет хотя бы для минимального курса генерировать корректные кандидаты (case `3 + 2/5`).

### 3.2. Входные данные

- Существующие файлы:
  - `src/mapmaster/MapMasterLite.ts` (или близкие по смыслу файлы);
  - `src/mapmaster/index.ts` (если есть);
  - тесты MapMaster из Claude-пакета (если присутствуют).
- Стабилизированный Invariants Registry и работающий loader (Шаги 1–2).

### 3.3. Подшаги

1. **Инвентаризация текущего MapMaster**  
   - Открыть `MapMasterLite.ts` и:
     - понять, какие типы там используются сейчас;
     - увидеть, как он принимает данные (expression, selection, invariants);
     - увидеть, что он возвращает (список кандидатов, их структура).
   - Зафиксировать, какие части кода можно напрямую использовать, а какие нужно переписать.

2. **Создание нового файла `mapmaster.core.ts`**  
   - В каталоге `src/mapmaster` создать `mapmaster.core.ts`.
   - Объявить в нём все типы TzV1.1 §6:
     - `MapMasterInput`
     - `MapMasterCandidateId`
     - `MapMasterCandidate`
     - `MapMasterResult`
   - Объявить функцию:

     ```ts
     export function mapMasterGenerate(input: MapMasterInput): MapMasterResult;
     ```

3. **Портирование/адаптация логики из MapMasterLite**  
   - Перенести в `mapmaster.core.ts` только необходимую логику:
     - выбор правил по active invariant set id;
     - проверка структуры выражения/selection;
     - формирование кандидатов (id, invariantRuleId, primitiveIds, targetPath, description).
   - Убедиться, что входы/выходы **строго** соответствуют TzV1.1:
     - не протаскиваются лишние поля;
     - всё, что не описано в контракте, остаётся внутри.

4. **Реализация минимальной поддержки курса**  
   - На первом этапе можно ограничиться **минимальным набором случаев**:
     - `3 + 2/5` и цепочка шагов из §15 TzV1.1:
       - “convert whole to fraction”,
       - “multiply by 5/5”,
       - “multiply numerators and denominators”,
       - “evaluate simple products”,
       - “add fractions with equal denominators”.
   - Важно:
     - не реализовывать сразу весь возможный зоопарк правил;
     - но построить структуру так, чтобы дальше можно было добавлять правила без ломки API.

5. **Написание unit-тестов для MapMaster Core**  
   - Тесты на:
     - отсутствие кандидатов, если ни одно правило не подходит;
     - наличие ровно одного кандидата для каждого шага в цепочке `3 + 2/5` при нужном выборе selectionPath;
     - корректность полей `invariantRuleId`, `primitiveIds`, `targetPath`.
   - Тесты должны работать **без Orchestrator’а**, только через Invariants Registry и MapMaster Core.

6. **Отключение/обрезка старого API**  
   - После того как `mapmaster.core.ts` стабилен и покрыт тестами:
     - обновить экспорт `src/mapmaster/index.ts`, чтобы он отдавал новый API;
     - по возможности, перестать использовать `MapMasterLite.ts` напрямую в других модулях;
     - либо оставить `MapMasterLite` как тонкую обёртку, которая вызывает `mapmaster.core.ts`.

7. **Мини-отчёт по шагу 3**  
   - Что умеет новый MapMaster Core;
   - Какие старые entry points теперь считаются deprecated;
   - Какие тесты покрывают основные кейсы.

### 3.4. Результат шага 3

- Есть чистый, независимый `mapmaster.core.ts` с понятным API.
- Он умеет обслуживать по крайней мере один полный пример учебной цепочки.
- Все вызовы MapMaster в будущем будут идти через этот модуль.

### 3.5. Критерии “готово” для шага 3

- Все тесты MapMaster Core проходят.
- Orchestrator (когда появится) сможет использовать MapMaster, не зная о старом `MapMasterLite`.
- Разработчик, глядя в TzV1.1 §6, легко узнает соответствующие типы/функции в коде.

---

## Шаг 4. StepMaster Core: упрощение и выравнивание (схематично)

**Цель:**  
Привести StepMaster к контракту TzV1.1 §7:

- создать `stepmaster.core.ts` с типами `StepMasterInput`, `StepMasterDecision`, `StepMasterResult`;
- реализовать `stepMasterDecide` с простейшей стратегией выбора кандидата;
- убрать/сжать старые `StepMasterLite`-варианты.

**Основные действия:**

1. Выписать все текущие статусы решений (enums) и привести к `"chosen" | "no-candidates"`.
2. Простой алгоритм: нет кандидатов → `no-candidates`, есть кандидаты → выбрать первый (или по приоритету).
3. Синхронизировать StepMaster с History Service (тип `StepMasterDecisionStatus` должен совпадать).
4. Написать unit-тесты на базовые кейсы.

---

## Шаг 5. Step History Service: приведение к TzV1.1 (схематично)

**Цель:**  
Сделать единый модуль истории, работающий per-request, с API TzV1.1 §8.

**Основные действия:**

1. Проверить и доработать `stepmaster.history-service.ts`:
   - типы `StepHistoryEntry`, `StepHistory`, `StepHistorySnapshot`;
   - функции `createEmptyHistory`, `appendStepFromResult`, `getSnapshot`.
2. Гарантировать immutability (всегда новый объект истории).
3. Уточнить семантику `candidateId = null` для `no-candidates`.
4. Написать тесты на:
   - пустую историю,
   - добавление шага,
   - корректную работу snapshot.

---

## Шаг 6. Step Policies: минимизация до student.default (схематично)

**Цель:**  
Сжать богатую policy-систему до минимального API TzV1.1 §9.

**Основные действия:**

1. Создать/обновить `stepmaster.policy-presets.ts` так, чтобы основной публичный API был:
   - `StepPolicyId = "student.default"`,
   - `StepPolicyConfig` с полем `maxCandidatesToShow`,
   - `createDefaultStudentPolicy()`.
2. Внутренние сложные политики (для будущего) можно оставить, но не экспортировать наружу.
3. Согласовать использование policy только через этот минимальный объект.

---

## Шаг 7. Engine Bridge: выравнивание контракта и NGIN stub (схематично)

**Цель:**  
Привести Engine Bridge к API TzV1.1 §10 и обеспечить минимальный stub для тестов.

**Основные действия:**

1. Обновить `engine.bridge.ts`:
   - типов `EngineStepExecutionRequest` и `EngineStepExecutionResult`;
   - сигнатуру `executeStepViaEngine(candidate, input)`.
2. Ввести простой stub для локальных тестов (например, “игровой” NGIN, который применяет простые шаги к LaTeX).
3. Добавить тесты, которые проверяют:
   - корректное формирование запроса движку;
   - корректную интерпретацию ответа/ошибок.

---

## Шаг 8. Step Orchestrator: реализация по TzV1.1 (схематично)

**Цель:**  
Реализовать `step.orchestrator.ts` строго по алгоритму TzV1.1 §11.

**Основные действия:**

1. Определить типы `OrchestratorContext`, `OrchestratorStepRequest`, `OrchestratorStepResult`.
2. Реализовать `runOrchestratorStep`:
   - создать пустую history,
   - вызвать MapMaster,
   - вызвать StepMaster,
   - обновить history,
   - при необходимости сходить в Engine Bridge,
   - вернуть статус/историю/результат.
3. Написать интеграционный тест, который:
   - поднимает Invariants Registry (через loader),
   - используется MapMaster, StepMaster, History, Policies, EngineBridge (stub),
   - прогоняет цепочку `3 + 2/5` как в примере TzV1.1 §15.

---

## Шаг 9. HTTP Server & HandlerPostEntryStep: единая точка входа (схематично)

**Цель:**  
Оставить один понятный endpoint `POST /api/entry-step` и адаптер над Orchestrator.

**Основные действия:**

1. Проверить текущие HTTP-роуты:
   - удалить/отключить старые, которые не соответствуют TzV1.1.
2. В `HandlerPostEntryStep`:
   - парсить `EntryStepRequest`,
   - создавать `OrchestratorStepRequest`,
   - собирать `OrchestratorContext` (registry + policy),
   - вызывать `runOrchestratorStep`,
   - маппить результат в `EngineStepResponse`.
3. Реализовать минимальную схему error handling (400/500 + `"engine-error"` на 200).

---

## Шаг 10. Logging & Error Handling: минимальная, но чёткая схема (схематично)

**Цель:**  
Сделать так, чтобы в логах было понятно, что пошло не так, а фронт получал стабильные статусы.

**Основные действия:**

1. Согласовать формат логов для:
   - ошибок course loader’а на старте,
   - ошибок NGIN,
   - внутренних исключений.
2. Гарантировать, что handler:
   - никогда не выбрасывает “сырая” ошибку наружу,
   - всегда возвращает JSON c `status` и, если нужно, `errorCode`.

---

## Шаг 11. Интеграционные тесты и пример учебной сессии (схематично)

**Цель:**  
Убедиться, что вся цепочка от HTTP до NGIN (stub) работает по TzV1.1.

**Основные действия:**

1. Написать интеграционный тест, который:
   - поднимает in-memory backend (без реального HTTP-сервера — можно вызывать handler как функцию);
   - последовательно отправляет запросы `EntryStepRequest` для кейса `3 + 2/5`;
   - проверяет, что мы получаем:
     - `3/1 + 2/5`,
     - `3/1 * 5/5 + 2/5`,
     - `(3 * 5) / (1 * 5) + 2/5`,
     - `15/5 + 2/5`,
     - `17/5`.
2. Проверить edge cases (нет кандидатов, ошибки NGIN).

---

## Шаг 12. Финализация, документация и релиз backend TzV1.1 (схематично)

**Цель:**  
Сделать backend готовым к использованию фронтендом и к дальнейшему расширению (TzV2+).

**Основные действия:**

1. Обновить документацию:
   - ссылку на `TZ.V1.1.md`,
   - добавить краткий README для backend (как запускать, как менять курс).
2. Настроить минимальный CI (test+lint), чтобы не ломать TzV1.1 контракт случайно.
3. Сформировать стабильный архив backend (без node_modules), который можно использовать как “эталон” для дальнейшей работы.

---

## Краткое резюме

- **Шаги 1–3** — это фундамент библиотеки (Invariants + Loader + MapMaster).  
  После их завершения backend уже будет иметь “сердце” курса и генерацию кандидатов.

- **Шаги 4–7** — доводят до ума decision layer (StepMaster, History, Policies) и мост к NGIN.

- **Шаги 8–10** — собирают orchestration и HTTP-слой в одну ясную цепочку.

- **Шаги 11–12** — закрывают интеграцию, тестирование и подготовку к релизу.

Эта дорожная карта задаёт простой и последовательный путь: **сначала библиотеки и данные, потом оркестратор, потом HTTP**, с опорой на TzV1.1 на каждом шаге.
