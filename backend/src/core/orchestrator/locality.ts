/**
 * locality.ts
 *
 * Helper functions to enforce click locality.
 * Ensures that candidates are anchored to the user's selection.
 */

/**
 * Checks if a candidate is local to the user's selection.
 * For Stage-1, we enforce strict equality between the candidate's target path
 * and the selection path.
 *
 * @param selectionPath The path selected by the user (e.g., "term[0].op").
 * @param selectionAstPath The resolved AST path from MapMaster.
 * @param candidate The candidate step generated by MapMaster.
 * @returns true if the candidate is local to the selection, false otherwise.
 */
export function isLocalToSelection(
  selectionPath: string | null | undefined,
  selectionAstPath: string | null | undefined,
  candidate: any
): boolean {
  // 1) If we have an AST selection anchor, use it
  if (selectionAstPath && selectionAstPath.trim() !== "") {
    const anchor = selectionAstPath.trim();
    const target = candidate.targetPath;

    if (target === anchor) return true;
    if (target === "root") return true; // Root contains everything
    if (anchor.startsWith(target + ".")) return true;
    if (target.startsWith(anchor + ".")) return true;
    return false;
  }

  // 2) Fallback: no AST anchor â†’ do NOT enforce locality for now
  return true;
}

/**
 * Find the binary operator node that "owns" the clicked selection.
 *
 * If the user clicks on a binary operator token (e.g. "+"), the selectionPath
 * usually points to that specific token or region. We want to find the
 * AstNode of type "binaryOp" that this token belongs to.
 *
 * Since our AST path mapping might point to the node itself (e.g. "term[0]"),
 * we need to check if the node at selectionAstPath IS a binaryOp.
 *
 * However, sometimes the click might be slightly "inside" or "around" it.
 * But typically, if they click the plus, the resolved path is the binaryOp node.
 */
export function getOperatorAnchorPath(
  ast: any,
  selectionAstPath: string | undefined,
  selectionPath: string | null,
  operatorIndex: number | undefined,
  getNodeAt: (ast: any, path: string) => any
): string | null {
  // If we have an explicit operator index, we trust the resolved path IF it's a binary op.
  if (typeof operatorIndex === "number" && selectionAstPath) {
    const node = getNodeAt(ast, selectionAstPath);
    if (node && node.type === "binaryOp") {
      return selectionAstPath;
    }
  }

  // Fallback: if selectionPath explicitly targets an operator token (e.g. ends in .op)
  // This handles cases where operatorIndex might be missing but UI is specific.
  if (selectionPath && (selectionPath.endsWith(".op") || selectionPath.includes(".op."))) {
    // If selectionAstPath is defined and is binaryOp, return it.
    if (selectionAstPath) {
      const node = getNodeAt(ast, selectionAstPath);
      if (node && node.type === "binaryOp") return selectionAstPath;
    }
  }

  return null;
}
